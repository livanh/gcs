#!/bin/bash

# GCS - Global Color Scheme
#
# Copyright (C) 2015 Livanh <livanh@bulletmail.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


GCS_MODULES_DIR_SYSTEM="/usr/share/gcs/modules"
GCS_MODULES_DIR_LOCAL="/usr/local/share/gcs/modules"
GCS_MODULES_DIR_USER="$HOME/.local/share/gcs/modules"
GCS_THEMES_DIR_SYSTEM="/usr/share/gcs/colorthemes"
GCS_THEMES_DIR_LOCAL="/usr/local/share/gcs/colorthemes"
GCS_THEMES_DIR_USER="$HOME/.config/gcs/colorthemes"
GCS_BASE16_SCHEMES_REPOSITORY="https://github.com/chriskempson/base16-schemes-source"
GCS_BASE16_SCHEMES_DIR_USER="$HOME/.config/gcs/base16"
GCS_BACKUPS_DIR="$HOME/.local/share/gcs/backups"

GCS_CONFIG_DIR="$HOME/.config/gcs"
GCS_CONFIG_FILE="${GCS_CONFIG_DIR}/gcs.conf"
GCS_TMP_DIR="$(mktemp -d -t .gcs-XXXXXX)"
GCS_LOCK_FILE="/tmp/.gcs_lock"

GCS_ACTION="apply-theme"
GCS_BACKUP_NAME=""


help() {
    echo "Usage:"
    echo "  to apply a color theme:   $0 [options] <color_theme_name>"
    echo "  to create a backup:       $0 [options] -b <backup_name>"
    echo "  to restore a backup:      $0 [options] -r <backup_name>"
    echo
    echo "Available options:"
    echo "  -m <module>    execute only one module"
    echo "  -h             show this help screen"
    echo "  -u             update base16 schemes"
    echo
    echo "Avilable color themes:"
    find "${GCS_THEMES_DIR_USER}" "${GCS_THEMES_DIR_LOCAL}" "${GCS_THEMES_DIR_SYSTEM}" \
        -mindepth 1 -maxdepth 1 -type d -printf "  %f\n" 2>/dev/null | sort | uniq | column
    echo
    echo "Avilable modules:"
    find "${GCS_MODULES_DIR_USER}" "${GCS_MODULES_DIR_LOCAL}" "${GCS_MODULES_DIR_SYSTEM}" \
        -mindepth 1 -maxdepth 1 -type f -executable -printf "  %f\n" 2>/dev/null | sort | uniq | column
    exit 1
}

update_base16_schemes() {
    local GCS_BASE16_LIST="${GCS_TMP_DIR}/base16-list"
    local GCS_BASE16_TEMP="${GCS_TMP_DIR}/base16-temp"
    [ -d "${GCS_BASE16_SCHEMES_DIR_USER}" ] || mkdir -p "${GCS_BASE16_SCHEMES_DIR_USER}"
    printf "Downloading base16 scheme list..."
    git clone "${GCS_BASE16_SCHEMES_REPOSITORY}" "${GCS_BASE16_LIST}" &> /dev/null
    if [ "$?" == "0" ]; then
        printf " done.\n"
    else
        printf " failed!\n"
        return
    fi
    echo "Downloading base16 schemes..."
    for i in $(awk '/: /{print $2}'  "${GCS_BASE16_LIST}/list.yaml" ); do
        echo "  $i..."
        git clone "$i" "${GCS_BASE16_TEMP}" &> /dev/null
        cp "${GCS_BASE16_TEMP}/"*.yaml "${GCS_BASE16_SCHEMES_DIR_USER}" &> /dev/null
        rm -rf "${GCS_BASE16_TEMP}" &> /dev/null
    done
    echo "Done."
}

while getopts ":m:b:r:hu" opt; do
    case $opt in
      m)
        FORCED_MODULE="$OPTARG"
        shift $((OPTIND-1))
        ;;
      b)
        GCS_ACTION="create-backup"
        GCS_BACKUP_NAME="$OPTARG"
        shift $((OPTIND-1))
        ;;
      r)
        GCS_ACTION="restore-backup"
        GCS_BACKUP_NAME="$OPTARG"
        shift $((OPTIND-1))
        ;;
      h)
        help
        ;;
      u)
        update_base16_schemes
        exit 1
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." >&2
        exit 1
        ;;
    esac
    OPTIND=1
done

if [ "${GCS_ACTION}" == "apply-theme" ]; then
    COLOR_THEME_NAME="$1"
    shift
fi


if [[ "${GCS_ACTION}" == "apply-theme" && "${COLOR_THEME_NAME}" == "" ]]; then
    help
fi

if [ "$#" -ne 0 ]; then
    help
fi

load_base16_scheme() {
    if [ "$#" -ne 1 ]; then
        echo "Error: load_base16_scheme() requires 1 argument!"
        exit 2
    fi

    local base16_scheme_file="${GCS_BASE16_SCHEMES_DIR_USER}/$1.yaml"
    if ! [ -f "${base16_scheme_file}" ]; then
        update_base16_schemes
        if ! [ -f "${base16_scheme_file}" ]; then
            echo "Error: base16 scheme $1 not found!"
            exit 3
        fi
    fi

    base00="$(awk '/base00:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base01="$(awk '/base01:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base02="$(awk '/base02:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base03="$(awk '/base03:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base04="$(awk '/base04:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base05="$(awk '/base05:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base06="$(awk '/base06:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base07="$(awk '/base07:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base08="$(awk '/base08:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base09="$(awk '/base09:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base0A="$(awk '/base0A:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base0B="$(awk '/base0B:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base0C="$(awk '/base0C:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base0D="$(awk '/base0D:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base0E="$(awk '/base0E:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
    base0F="$(awk '/base0F:/{print "#"substr($2,2,6)}' "${base16_scheme_file}")"
}

# Load a color theme file.
# egrep is used to only select lines which contain declaration for variables containing only
# alphanumeric characters, hashtags (for hexadecimal colours, i.e. #FF0000), dollar signs and underscores
# (to reuse other variables, i.e. var=$var_2), dots (for filenames) and hyphens (for icon theme names).
# Single or double quotes are permitted.
load_color_theme() {

    if [ "$#" -ne 1 ]; then
        echo "Error: load_color_theme() requires 1 argument!"
        exit 2
    fi

    FULL_COLOR_THEME_NAME="gcs-${COLOR_THEME_NAME}"

    COLOR_THEME_FILES=()
    COLOR_THEME_DIRS=()

    if  [ -f "${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}/colortheme" ]; then
        COLOR_THEME_FILES+=("${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}/colortheme")
        COLOR_THEME_DIRS+=("${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}")
    fi

    if  [ -f "${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}/colortheme" ]; then
        COLOR_THEME_FILES+=("${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}/colortheme")
        COLOR_THEME_DIRS+=("${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}")
    fi

    if [ -f "${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}/colortheme" ]; then
        COLOR_THEME_FILES+=("${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}/colortheme")
        COLOR_THEME_DIRS+=("${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}")
    fi

    # clear environment
    unset $(/usr/bin/env | egrep '^(\w+)=(.*)$' | egrep -vw 'PWD|USER|HOME|LANG|PATH' | /usr/bin/cut -d= -f1 );
    pid=$(ps -o ppid= -p $$)
    eval export $(cat /proc/${pid## }/environ | tr "\0" "\n" | grep -v \; | grep -v "\[" | sed "s/=/=\"/" | sed "s/$/\"\n/")

    # read color theme file
    for color_theme_file in ${COLOR_THEME_FILES[@]}; do
        eval $(egrep "^[[:alnum:]_]+=([[:alnum:]_#$\{\}.-]+|\"[[:alnum:]_#$\{\}.-]+\"|'[[:alnum:]_#$\{\}.-]+')$" "${color_theme_file}")
    done

    # apply default values to some variables by referencing other variables

    # base colors
    #~ unset base_color
    #~ unset text_color
    #~ unset bg_color
    #~ unset fg_color
    #~ unset selected_bg_color
    #~ unset selected_fg_color
    : ${tooltip_fg_color:=${fg_color}}
    : ${tooltip_border_color:=${fg_color}}
    : ${tooltip_bg_color:=${bg_color}}


    # icon and cursor theme
    #~ unset icon_theme_name
    #~ unset cursor_theme_name

    # error/warning
    #~ unset error_color
    #~ unset warning_bg_color

    # window manager colors
    : ${titlebar_urgent_bg_color:=${selected_bg_color}}
    : ${titlebar_urgent_fg_color:=${selected_fg_color}}
    : ${titlebar_focused_bg_color:=${selected_bg_color}}
    : ${titlebar_focused_fg_color:=${selected_fg_color}}
    : ${titlebar_unfocused_bg_color:=${base_color}}
    : ${titlebar_unfocused_fg_color:=${text_color}}

    # link colors
    : ${link_color:=${selected_bg_color}}
    : ${link_visited_color:=${text_color}}

    # tray bar colors
    : ${tray_bg_color:=${bg_color}}
    : ${tray_fg_color:=${fg_color}}
    : ${tray_focused_bg_color:=${titlebar_focused_bg_color}}
    : ${tray_focused_fg_color:=${titlebar_focused_fg_color}}
    : ${tray_unfocused_bg_color:=${bg_color}}
    : ${tray_unfocused_fg_color:=${fg_color}}
    : ${tray_urgent_bg_color:=${titlebar_urgent_bg_color}}
    : ${tray_urgent_fg_color:=${titlebar_urgent_fg_color}}

    # background
    #~ unset wallpaper_image
    #~ unset wallpaper_mode
    : ${wallpaper_bg_color:=${bg_color}}
    : ${wallpaper_text_color:=${text_color}}
    : ${wallpaper_shadow_color:=${bg_color}}

    # terminal
    : ${terminal_bg_color:=${fg_color}}
    : ${terminal_fg_color:=${bg_color}}
    #~ unset terminal_palette_black
    #~ unset terminal_palette_red
    #~ unset terminal_palette_green
    #~ unset terminal_palette_yellow
    #~ unset terminal_palette_blue
    #~ unset terminal_palette_purple
    #~ unset terminal_palette_cyan
    #~ unset terminal_palette_white
    #~ unset terminal_palette_light_black
    #~ unset terminal_palette_light_red
    #~ unset terminal_palette_light_green
    #~ unset terminal_palette_light_yellow
    #~ unset terminal_palette_light_blue
    #~ unset terminal_palette_light_purple
    #~ unset terminal_palette_light_cyan
    #~ unset terminal_palette_light_white
    #~ unset terminal_transparency

    # notifications
    : ${notification_border_color:=${bg_color}}
    : ${notification_bg_color:=${bg_color}}
    : ${notification_fg_color:=${fg_color}}

    # text editors with syntax highlighting
    : ${editor_syntax_enable:=false}
    : ${editor_bg:=${base_color}}
    : ${editor_fg:=${text_color}}
    : ${editor_selected_bg:=${selected_bg_color}}
    : ${editor_selected_fg:=${selected_fg_color}}
    : ${editor_frame_bg:=${bg_color}}
    : ${editor_frame_fg:=${fg_color}}
    : ${editor_current_line_bg:=${bg_color}}
    : ${editor_indent_guide:=${editor_string}}
    : ${editor_long_line_marker:=${editor_current_line_bg}}
    : ${editor_caret:=${text_color}}
    : ${editor_error:=${error_color}}
    : ${editor_brace_good:=${editor_string}}
    : ${editor_brace_bad:=${error_color}}

    #~ unset editor_comment
    : ${editor_white_space:=${editor_comment}}
    #~ unset editor_number
    #~ unset editor_string
    : ${editor_keyword:=${selected_bg_color}}
    #~ unset editor_operator
    #~ unset editor_preprocessor
    : ${editor_section_header:=${editor_preprocessor}}
    #~ unset editor_class
    : ${editor_character:=${editor_number}}

    #~ unset editor_tag
    #~ unset editor_tag_unknown
    #~ unset editor_tag_end
    #~ unset editor_attribute
    #~ unset editor_attribute_unknown
    #~ unset editor_value
    #~ unset editor_entity

    #~ unset editor_diff_added
    #~ unset editor_diff_removed
    #~ unset editor_diff_changed

}

# set the value of the key named $KEY (in text file $FILE) equal to $VALUE
# assuming they are separated by $SEPARATOR
# warning: do not use for config file with different sections, because
# if the key does not exist, it will be created at the end of the file
set_value() {
    if [ "$#" -ne 4 ]; then
        echo "Error: set_value() requires 4 arguments!"
        exit 2
    fi
    local KEY=$1
    local SEPARATOR=$2
    local VALUE=$3
    local FILE=$4
    if grep -E "^([[:space:]]*|(.*[[:space:]]+))*${KEY}${SEPARATOR}.*" "${FILE}" >/dev/null; then
        sed -r -i "s/^([[:space:]]*|(.*[[:space:]]+))*${KEY}${SEPARATOR}.*/$(grep -E "^([[:space:]]*|(.*[[:space:]]+))*${KEY}" "${FILE}" | sed "s/${KEY}.*//")${KEY}${SEPARATOR}${VALUE}/" "${FILE}"
    else
        echo "${KEY}${SEPARATOR}${VALUE}" >>"${FILE}"
    fi
}

# set the value of the key named $KEY (in section [section] on text
# file $FILE) equal to $VALUE, assuming they are separated by $SEPARATOR
# TODO: define behaviour when $SECTION is not found
set_value_section() {
    if [ "$#" -ne 5 ]; then
        echo "Error: set_value_section() requires 5 arguments!"
        exit 2
    fi
    local SECTION=$1
    local KEY=$2
    local SEPARATOR=$3
    local VALUE=$4
    local FILE=$5
    local old_section="$(grep -Pzo "\[${SECTION}\](.|\n)*?\[" "${FILE}" | tr -d \\0)"
    local tmp_file="${GCS_TMP_DIR}/set_value_temp"
    echo "$old_section" >"$tmp_file"
    set_value "$KEY" "$SEPARATOR" "$VALUE" "$tmp_file"
    perl -i -p0e "s/\Q${old_section}\E/$(cat $tmp_file)/" ${FILE}
    rm $tmp_file
}

cleanup() {
    rm "${GCS_LOCK_FILE}"
    rm -r "${GCS_TMP_DIR}" &>/dev/null
}

if [ -f "${GCS_LOCK_FILE}" ]; then
    echo "Error: lockfile \"${GCS_LOCK_FILE}\" exists, exiting."
    exit 3
fi

if [ "${GCS_ACTION}" == "apply-theme" ]; then
    if [ -f "${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}/colortheme" ]; then true
    elif  [ -f "${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}/colortheme" ]; then true
    elif  [ -f "${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}/colortheme" ]; then true
    else
        echo "Error: theme \"${COLOR_THEME_NAME}\" not found!"
        exit 2
    fi

    echo "Applying color theme ${COLOR_THEME_NAME}"

elif [ "${GCS_ACTION}" == "create-backup" ]; then
    if [ -d "${GCS_BACKUPS_DIR}/${GCS_BACKUP_NAME}" ]; then
        echo "Error: backup \"${GCS_BACKUP_NAME}\" already exists!"
        exit 3
    fi

    echo "Creating backup in \"${GCS_BACKUPS_DIR}/${GCS_BACKUP_NAME}\""

elif [ "${GCS_ACTION}" == "restore-backup" ]; then
    if ! [ -d "${GCS_BACKUPS_DIR}/${GCS_BACKUP_NAME}" ]; then
        echo "Error: backup \"${GCS_BACKUP_NAME}\" does not exist!"
        exit 4
    fi

    echo "Restoring backup from \"${GCS_BACKUPS_DIR}/${GCS_BACKUP_NAME}\""

fi

touch "${GCS_LOCK_FILE}"
trap "cleanup; exit 1" INT

# create an array of modules to execute
MODULES=()

for i in "${GCS_MODULES_DIR_SYSTEM}/"* "${GCS_MODULES_DIR_LOCAL}/"* "${GCS_MODULES_DIR_USER}/"*; do
    if [ -x "$i" ]; then
        MODULE_NAME="${i##/*/}"

        if ! [ -z "${FORCED_MODULE}" ]; then
            if ! [ "$MODULE_NAME" == "${FORCED_MODULE}" ]; then
                continue
            fi
        fi

        for j in ${!MODULES[@]}; do
            if [ "${MODULE_NAME}" == "${MODULES[j]##/*/}" ]; then
                MODULES[$j]=''
            fi
        done
        MODULES+=("$i")
    fi
done

# execute modules
for module_file in ${MODULES[@]}; do
    # Load color theme file. It is loaded before each module to prevent modules from modifying the colors.
    load_color_theme "${COLOR_THEME_NAME}"
    # Load a module
    . "${module_file}"
done

cleanup

