#!/bin/bash

# GCS - Global Color Scheme
#
# Copyright (C) 2015 Livanh <livanh@bulletmail.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


GCS_MODULES_DIR_SYSTEM="/usr/share/gcs/modules"
GCS_MODULES_DIR_LOCAL="/usr/local/share/gcs/modules"
GCS_MODULES_DIR_USER="$HOME/.local/share/gcs/modules"
GCS_THEMES_DIR_SYSTEM="/usr/share/gcs/colorthemes"
GCS_THEMES_DIR_LOCAL="/usr/local/share/gcs/colorthemes"
GCS_THEMES_DIR_USER="$HOME/.config/gcs/colorthemes"

GCS_CONFIG_DIR="$HOME/.config/gcs"
GCS_CONFIG_FILE="${GCS_CONFIG_DIR}/gcs.conf"
GCS_TMP_DIR="$(mktemp -d -t .gcs-XXXXXX)"
GCS_LOCK_FILE="/tmp/.gcs_lock"

while getopts "m:" opt; do
  case $opt in
    m)
      FORCED_MODULE="$OPTARG"
      #echo forced module: $OPTARG
      shift
      shift
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 [options] <color_theme_name>"
    echo
    echo "Available options:"
    echo -e "\t-m <module>\texecute only one module"
    echo
    echo "Avilable color themes:"
    find "${HOME}/.config/gcs/colorthemes" "/usr/local/share/gcs/colorthemes" "/usr/share/gcs/colorthemes" \
        -mindepth 1 -maxdepth 1 -type d -printf "\t%f\n" 2>/dev/null | sort | uniq
    exit 1
fi
COLOR_THEME_NAME="$1"

# Load a color theme file.
# egrep is used to only select lines which contain declaration for variables containing only
# alphanumeric characters, hashtags (for hexadecimal colours, i.e. #FF0000), dollar signs and underscores
# (to reuse other variables, i.e. var=$var_2), dots (for filenames) and hyphens (for icon theme names).
# Single or double quotes are permitted.
load_color_theme() {

    if [ "$#" -ne 1 ]; then
        echo "Error: load_color_theme() requires 1 argument!"
        exit 2
    fi

    COLOR_THEME_FILES=()
    COLOR_THEME_DIRS=()

    if  [ -f "${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}/colortheme" ]; then
        COLOR_THEME_FILES+=("${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}/colortheme")
        COLOR_THEME_DIRS+=("${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}")
    fi

    if  [ -f "${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}/colortheme" ]; then
        COLOR_THEME_FILES+=("${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}/colortheme")
        COLOR_THEME_DIRS+=("${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}")
    fi

    if [ -f "${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}/colortheme" ]; then
        COLOR_THEME_FILES+=("${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}/colortheme")
        COLOR_THEME_DIRS+=("${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}")
    fi

    # clear environment
    unset $(/usr/bin/env | egrep '^(\w+)=(.*)$' | egrep -vw 'PWD|USER|HOME|LANG|PATH' | /usr/bin/cut -d= -f1 );
    pid=$(ps -o ppid= -p $$)
    eval export $(cat /proc/${pid## }/environ | tr "\0" "\n" | grep -v \; | grep -v "\[" | sed "s/=/=\"/" | sed "s/$/\"\n/")

    # read color theme file
    for color_theme_file in ${COLOR_THEME_FILES[@]}; do
        eval $(egrep "^[[:alnum:]_]+=([[:alnum:]_#$\{\}.-]+|\"[[:alnum:]_#$\{\}.-]+\"|'[[:alnum:]_#$\{\}.-]+')$" "${color_theme_file}")
    done

    # apply default values to some variables by referencing other variables

    # base colors
    #~ unset base_color
    #~ unset text_color
    #~ unset bg_color
    #~ unset fg_color
    #~ unset selected_bg_color
    #~ unset selected_fg_color
    : ${accent_color:=${selected_bg_color}}

    # icon and cursor theme
    #~ unset icon_theme_name
    #~ unset cursor_theme_name

    # error/warning
    #~ unset error_color
    #~ unset warning_bg_color

    # window manager colors
    : ${titlebar_urgent_bg_color:=${selected_bg_color}}
    : ${titlebar_urgent_fg_color:=${selected_fg_color}}
    : ${titlebar_focused_bg_color:=${selected_bg_color}}
    : ${titlebar_focused_fg_color:=${selected_fg_color}}
    : ${titlebar_unfocused_bg_color:=${base_color}}
    : ${titlebar_unfocused_fg_color:=${text_color}}

    # link colors
    : ${link_color:=${selected_bg_color}}
    : ${link_visited_color:=${text_color}}

    # tray bar colors
    : ${tray_bg_color:=${bg_color}}
    : ${tray_fg_color:=${fg_color}}
    : ${tray_focused_bg_color:=${titlebar_focused_bg_color}}
    : ${tray_focused_fg_color:=${titlebar_focused_fg_color}}
    : ${tray_unfocused_bg_color:=${bg_color}}
    : ${tray_unfocused_fg_color:=${fg_color}}
    : ${tray_urgent_bg_color:=${titlebar_urgent_bg_color}}
    : ${tray_urgent_fg_color:=${titlebar_urgent_fg_color}}

    # background
    #~ unset wallpaper_image
    #~ unset wallpaper_mode
    : ${wallpaper_bg_color:=${bg_color}}
    : ${wallpaper_text_color:=${text_color}}
    : ${wallpaper_shadow_color:=${bg_color}}

    # terminal
    : ${terminal_bg_color:=${fg_color}}
    : ${terminal_fg_color:=${bg_color}}
    #~ unset terminal_palette_black
    #~ unset terminal_palette_red
    #~ unset terminal_palette_green
    #~ unset terminal_palette_yellow
    #~ unset terminal_palette_blue
    #~ unset terminal_palette_purple
    #~ unset terminal_palette_cyan
    #~ unset terminal_palette_white
    #~ unset terminal_palette_light_black
    #~ unset terminal_palette_light_red
    #~ unset terminal_palette_light_green
    #~ unset terminal_palette_light_yellow
    #~ unset terminal_palette_light_blue
    #~ unset terminal_palette_light_purple
    #~ unset terminal_palette_light_cyan
    #~ unset terminal_palette_light_white
    #~ unset terminal_transparency

    # notifications
    : ${notification_border_color:=${bg_color}}
    : ${notification_bg_color:=${bg_color}}
    : ${notification_fg_color:=${fg_color}}

    # text editors with syntax highlighting
    : ${editor_syntax_enable:=false}
    : ${editor_bg:=${base_color}}
    : ${editor_fg:=${text_color}}
    : ${editor_selected_bg:=${selected_bg_color}}
    : ${editor_selected_fg:=${selected_fg_color}}
    : ${editor_frame_bg:=${bg_color}}
    : ${editor_frame_fg:=${fg_color}}
    : ${editor_current_line_bg:=${bg_color}}
    : ${editor_indent_guide:=${editor_string}}
    : ${editor_long_line_marker:=${editor_current_line_bg}}
    : ${editor_caret:=${text_color}}
    : ${editor_error:=${error_color}}
    : ${editor_brace_good:=${editor_string}}
    : ${editor_brace_bad:=${error_color}}

    #~ unset editor_comment
    : ${editor_white_space:=${editor_comment}}
    #~ unset editor_number
    #~ unset editor_string
    : ${editor_keyword:=${selected_bg_color}}
    #~ unset editor_operator
    #~ unset editor_preprocessor
    : ${editor_section_header:=${editor_preprocessor}}
    #~ unset editor_class
    : ${editor_character:=${editor_number}}

    #~ unset editor_tag
    #~ unset editor_tag_unknown
    #~ unset editor_tag_end
    #~ unset editor_attribute
    #~ unset editor_attribute_unknown
    #~ unset editor_value
    #~ unset editor_entity

    #~ unset editor_diff_added
    #~ unset editor_diff_removed
    #~ unset editor_diff_changed

}

# set the value of the key named $KEY (in text file $FILE) equal to $VALUE
# assuming they are separated by $SEPARATOR
# warning: do not use for config file with different sections, because
# if the key does not exist, it will be created at the end of the file
set_value() {
    if [ "$#" -ne 4 ]; then
        echo "Error: set_value() requires 4 arguments!"
        exit 2
    fi
    local KEY=$1
    local SEPARATOR=$2
    local VALUE=$3
    local FILE=$4
    if grep -E "^([[:space:]]*|(.*[[:space:]]+))*${KEY}${SEPARATOR}.*" "${FILE}" >/dev/null; then
        sed -r -i "s/^([[:space:]]*|(.*[[:space:]]+))*${KEY}${SEPARATOR}.*/$(grep -E "^([[:space:]]*|(.*[[:space:]]+))*${KEY}" "${FILE}" | sed "s/${KEY}.*//")${KEY}${SEPARATOR}${VALUE}/" "${FILE}"
    else
        echo "${KEY}${SEPARATOR}${VALUE}" >>"${FILE}"
    fi
}

# set the value of the key named $KEY (in section [section] on text
# file $FILE) equal to $VALUE, assuming they are separated by $SEPARATOR
# TODO: define behaviour when $SECTION is not found
set_value_section() {
    if [ "$#" -ne 5 ]; then
        echo "Error: set_value_section() requires 5 arguments!"
        exit 2
    fi
    local SECTION=$1
    local KEY=$2
    local SEPARATOR=$3
    local VALUE=$4
    local FILE=$5
    local old_section="$(grep -Pzo "\[${SECTION}\](.|\n)*?\[" "${FILE}" | tr -d \\0)"
    local tmp_file="$(mktemp)"
    echo "$old_section" >"$tmp_file"
    set_value "$KEY" "$SEPARATOR" "$VALUE" "$tmp_file"
    perl -i -p0e "s/\Q${old_section}\E/$(cat $tmp_file)/" ${FILE}
    rm $tmp_file
}

remove_lock_file() {
    rm "${GCS_LOCK_FILE}"
}


if [ -f "${GCS_THEMES_DIR_USER}/${COLOR_THEME_NAME}/colortheme" ]; then true
elif  [ -f "${GCS_THEMES_DIR_LOCAL}/${COLOR_THEME_NAME}/colortheme" ]; then true
elif  [ -f "${GCS_THEMES_DIR_SYSTEM}/${COLOR_THEME_NAME}/colortheme" ]; then true
else
    echo "Error: theme \"${COLOR_THEME_NAME}\" not found!"
    exit 2
fi

if [ -f "${GCS_LOCK_FILE}" ]; then
    echo "Error: lockfile \"${GCS_LOCK_FILE}\" exists, exiting."
    exit 3
fi

echo "Applying color theme ${COLOR_THEME_NAME}"
touch "${GCS_LOCK_FILE}"
trap "remove_lock_file; exit 1" INT

# create an array of modules to execute
MODULES=()

for i in "${GCS_MODULES_DIR_SYSTEM}/"* "${GCS_MODULES_DIR_LOCAL}/"* "${GCS_MODULES_DIR_USER}/"*; do
    if [ -x "$i" ]; then
        MODULE_NAME="${i##/*/}"

        if ! [ -z "${FORCED_MODULE}" ]; then
            if ! [ "$MODULE_NAME" == "telegram" ]; then
                continue
            fi
        fi

        for j in ${!MODULES[@]}; do
            if [ "${MODULE_NAME}" == "${MODULES[j]##/*/}" ]; then
                MODULES[$j]=''
            fi
        done
        MODULES+=("$i")
    fi
done

# execute modules
for module_file in ${MODULES[@]}; do
    # Load color theme file. It is loaded before each module to prevent modules from modifying the colors.
    load_color_theme "${COLOR_THEME_NAME}"
    # Load a module
    . "${module_file}"
done

remove_lock_file

rm -r "${GCS_TMP_DIR}" &>/dev/null

